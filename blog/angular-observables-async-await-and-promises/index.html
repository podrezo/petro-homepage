<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="Petro Podrezo: Full-stack Software Developer"><meta name=author content="Petro Podrezo"><title>Petro Podrezo: Angular: Observables, async/await, and Promises, oh my!</title>
<link rel=icon type=image/svg+xml href=/braces.svg><link rel="alternate icon" ype=image/png href=/braces.png><link rel=stylesheet href=https://podrezo.com/root.min.72cf4243004aca2307043426448db7e2e9e2633cbd58de7807f5998fdd4b55be.css></head><body><div class="container mt-5"><header class=mb-5><h1 class=title><img src=/braces.svg type=image/svg+xml> Petro Podrezo <small>Software Engineer</small></h1><nav class="nav nav-underline justify-content-center mt-5"><a class=nav-link href=https://podrezo.com/>Home</a>
<a class=nav-link href=https://podrezo.com/blog/>Blog</a>
<a class=nav-link href=https://podrezo.com/mentorship/>Mentorship</a>
<a class=nav-link href=https://podrezo.com/projects/>Projects</a>
<a class=nav-link href=https://podrezo.com/contact/>Contact</a></nav></header><nav aria-label=breadcrumb class="mt-2 breadcrumbnav"><ol class=breadcrumb><li class=breadcrumb-item><a href=https://podrezo.com/>Home</a></li><li class=breadcrumb-item><a href=https://podrezo.com/blog/>Blog</a></li><li class="breadcrumb-item active" aria-current=page>Angular: Observables, async/await, and Promises, oh my!</li></ol></nav><article class=row><div class=col-lg-12><h1 id=angular-observables-asyncawait-and-promises-oh-my>Angular: Observables, async/await, and Promises, oh my!</h1><p>Coming from the pre-Angular2 Angular.js world, Angular (which is already at version 5 at the time of writing) can seem daunting with its insistence of using the <a href=https://en.wikipedia.org/wiki/Observer_pattern>Observer/Observable design pattern</a>. Everywhere you look, things seem to return an <a href=http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html>RxJS Observable</a> instead of that nice familiar promise we all know (and maybe even love?). When trying to pick up Angular, this was super frustrating and my gut reaction was to use the very-handy <code>toPromise()</code> method that Observables provide and take the easy way out, but I convinced myself to learn it since I was sure there was a reason for all this madness. Now I think I finally understand it and I’d like to share what I found out.</p><hr><p>So let’s start off basic — why use observable at all and not rely entirely on promises? Well, that one’s easy — you can read <a href=https://stackoverflow.com/questions/37364973/angular-promise-vs-observable>this more detailed answer on stackoverflow</a> but the gist of it is that Observables allow you to cancel an ongoing task, they allow you to return multiple things, and allow you to have multiple subscribers to a single Observable instance. It also simplifies having to retry.</p><p>So let’s say you had the following promise-based code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>doAsyncPromiseThing</span>()
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>then</span>(() <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;I&#39;m done!&#34;</span>))
</span></span><span style=display:flex><span>  .<span style=color:#66d9ef>catch</span>(() <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Error&#39;d out&#34;</span>))
</span></span></code></pre></div><p>In “Observable land” this is really not any more complicated:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>doAsyncObservableThing</span>()
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>subscribe</span>(
</span></span><span style=display:flex><span>     () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;I&#39;m done!&#34;</span>),
</span></span><span style=display:flex><span>     () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Error&#39;d out&#34;</span>)
</span></span><span style=display:flex><span>  )
</span></span></code></pre></div><h3 id=your-own-first-observable>Your own first observable</h3><p>A lot of guides I read dive into making HTTP requests right away with observables since that is pragmatically where you will use them most, but I want to do things a bit differently in this article and get at the meat of what Observables are like without trying to make it practical right away. So how do we simply return a value in an async way using Observable? Well there’s two ways — we can use the constructor of it, or use the create method, both of which do the same thing (they are aliases of each other).</p><p>By the way I’ll be basing the rest of this article around some of the helper methods here, so for this first example I’ll post the full component’s source so you can follow along easier in something like Plnkr if you want to.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>//our root app component
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> {<span style=color:#a6e22e>Component</span>, <span style=color:#a6e22e>NgModule</span>} <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@angular/core&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> {<span style=color:#a6e22e>BrowserModule</span>} <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@angular/platform-browser&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> {<span style=color:#a6e22e>Observable</span>} <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs/Observable&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Component</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>selector</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;my-app&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;div&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &lt;h2&gt;Observable Example&lt;/h2&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &lt;ul&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &lt;li *ngFor=&#34;let message of messages&#34;&gt;{{message}}&lt;/li&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &lt;/ul&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  `</span>,
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>App</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>initialTime</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>messages</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>log</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>m</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>dateDifference</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>() <span style=color:#f92672>-</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>initialTime</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>messages</span>.<span style=color:#a6e22e>push</span>(<span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>dateDifference</span><span style=color:#e6db74>}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>m</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Observable</span>(<span style=color:#a6e22e>observer</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>next</span>(<span style=color:#e6db74>&#39;Hello, observable world!&#39;</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>complete</span>();
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span>.<span style=color:#a6e22e>subscribe</span>(
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>log</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@NgModule</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>imports</span><span style=color:#f92672>:</span> [ <span style=color:#a6e22e>BrowserModule</span> ],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>declarations</span><span style=color:#f92672>:</span> [ <span style=color:#a6e22e>App</span> ],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>bootstrap</span><span style=color:#f92672>:</span> [ <span style=color:#a6e22e>App</span> ]
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppModule</span> {}
</span></span></code></pre></div><p>So when you run this you should see “Hello, observable world!” because the observable completes immediately. Note that my helper “log” method adds the number of microseconds since the app loaded to each message so we can get more interesting with the next example: things that take some time to finish. Before we get there though — take note of the fact that our observer has a next and complete method that we’re using in the example above. While it’s tempting to view “.subscribe()” as being akin to the “.then()” of a promise, it is far from the truth. The fact is that next() can be called multiple times as an observable can return multiple results. In fact, there are <strong><em>infinite and finite observables</em></strong>. As the names imply, finite observables return a set number of results while infinite observables can go on forever.</p><p>I’d also like to add here that there’s very simple shorthands for many of these common tasks like what we just did above — for example instead of defining the observable as I had done there one can simply do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Observable</span>.<span style=color:#66d9ef>of</span>(<span style=color:#e6db74>&#39;Hello, observable world!&#39;</span>);
</span></span></code></pre></div><p>Which does exactly the same thing as above, and is a lot simpler. This is akin to $q.when(‘Hello’) from the Angular.js world. Note that you need to add the following import to the top of your file to access some of these helpers in Angular:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;rxjs/add/observable/of&#39;</span>;
</span></span></code></pre></div><p>Another neat thing to note here is that <a href=https://stackoverflow.com/questions/38008334/angular-rxjs-when-should-i-unsubscribe-from-subscription>you do not need to unsubscribe from finite observables</a> — RxJS will take care of it for you. See what happens if you try the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Observable</span>(<span style=color:#a6e22e>observer</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>next</span>(<span style=color:#e6db74>&#39;Started&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setTimeout</span>(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>next</span>(<span style=color:#e6db74>&#39;Hello, observable world!&#39;</span>);
</span></span><span style=display:flex><span>  }, <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setTimeout</span>(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>next</span>(<span style=color:#e6db74>&#39;Done&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>complete</span>();
</span></span><span style=display:flex><span>  }, <span style=color:#ae81ff>2000</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>What you’ll see is the following:</p><ul><li>0: Started</li><li>1001: Hello, observable world!</li><li>2001: Done</li></ul><p>Note that depending on the situation, you’re probably better off using something like <a href=https://www.learnrxjs.io/operators/utility/delay.html>delay()</a> instead of setTimeout for timing purposes with your observables; I’m just using setTimeout here to show a point.</p><p>So because we are still using the subscribe method, we will stay subscribed and get our log function invoked every time as we expect, but we have no way of knowing when the observable fully completes even though this is a finite observable where we’re calling the “observer.complete()” method. So to rectify that, let’s modify our subscription slightly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Observable</span>(<span style=color:#a6e22e>observer</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>next</span>(<span style=color:#e6db74>&#39;Started&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setTimeout</span>(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>next</span>(<span style=color:#e6db74>&#39;Hello, observable world!&#39;</span>);
</span></span><span style=display:flex><span>  }, <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setTimeout</span>(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>complete</span>();
</span></span><span style=display:flex><span>  }, <span style=color:#ae81ff>2000</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span>.<span style=color:#a6e22e>forEach</span>(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>log</span>
</span></span><span style=display:flex><span>).<span style=color:#a6e22e>then</span>(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Done&#39;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>In the above example I have changed the subscribe() method into a forEach(). The forEach() method returns… a promise! so we can simply do a .then() on the result of forEach() which will be invoked when the observable has fully completed. The rule of thumb is when you expect something to happen once and be done you should probably be using subscribe() and if you’re expecting multiple results you should probably be using forEach().</p><h3 id=chaining-observables>Chaining Observables</h3><p>One of the most annoying things for me to figure out when I started working with Observable was how to chain them together — specifically I had a scenario where I had two HTTP requests that needed to happen in sequence, with some processing of the results in-between.</p><p>The naive solution to this is to simply subscribe inside the subscription:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Observable</span>(<span style=color:#a6e22e>observer</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setTimeout</span>(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>next</span>(<span style=color:#e6db74>&#39;Hello, observable world!&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>complete</span>();
</span></span><span style=display:flex><span>  }, <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span>.<span style=color:#a6e22e>subscribe</span>((<span style=color:#a6e22e>val</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>val</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span>.<span style=color:#a6e22e>subscribe</span>((<span style=color:#a6e22e>val</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>val</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Note that the above will work, you will see the following:</p><ul><li>1001: Hello, observable world!</li><li>2001: Hello, observable world!</li></ul><p>However the code is just plain ugly and anything even marginally more complicated will quickly grow to be unmaintainable. So what can we do? Well another naive solution is to just use the toPromise() method on the observables and chain them together that way, but again that’s taking the easy way out and not really thinking with Observables. So what to do? Well there’s a couple things you can do, but before we get to that it’s important to understand that <strong>unlike promises, you don’t keep chaining subscribes() similar to how you would chain then()’s</strong>. Instead, there’s a few solutions depending on what you’re looking for.</p><h3 id=start-all-tasks-immediately-get-the-results-one-by-one-merge>Start all tasks immediately, get the results one by one (merge)</h3><p>First, let’s try importing merge using import ‘rxjs/add/operator/merge’;</p><p>Next let’s try</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span>(<span style=color:#e6db74>&#39;First&#39;</span>)
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>merge</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span>(<span style=color:#e6db74>&#39;Second&#39;</span>))
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>subscribe</span>((<span style=color:#a6e22e>v</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>v</span>);
</span></span><span style=display:flex><span>  });
</span></span></code></pre></div><p>Our result looks like this:</p><ul><li>1002: First</li><li>1002: Second</li></ul><p>The key takeaway from this experiment is that the callback in subscribe() is invoked twice, once for ‘First’ and once for ‘Second’ but the intervals are starting from the same time — the timing confirms both complete after one second.</p><h3 id=observables-in-sequence-using-asyncawait>Observables in sequence, using async/await</h3><p>Now, this next one is going to use toPromise() because I haven’t found a better way around this yet, but it uses so sparingly and still remains the cleanest way I have found to accomplish what we did with the nested subscribe()’s without actually nesting them and that is to use the async and await keywords. Firstly, we will have to move our code into the NgOnInit method because a constructor cannot be async and that’s where we’ve had our code so far; next let’s talk briefly about the async and await keywords.</p><p>Async is a keyword that denotes a method is allowed to use the await keyword, and that it returns a promise (you have to make sure to specify a return value that is Promise-compatible, e.g. Promise ). The await keyword suspends execution of the async function until the promise has resolved or rejected — it must always be followed by an expression that evaluates to a promise. So let’s see this in action:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span>(<span style=color:#e6db74>&#39;First&#39;</span>).<span style=color:#a6e22e>toPromise</span>());
</span></span><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doAsyncObservableThing</span>(<span style=color:#e6db74>&#39;Second&#39;</span>).<span style=color:#a6e22e>toPromise</span>());
</span></span></code></pre></div><p>Notice that the call to this.log() will be suspended until the expression involving await can be evaluated, which is only after the promise resolves. This means that our result looks like this:</p><ul><li>1005: First</li><li>2009: Second</li></ul><p>With the timings we expect, where the second observable doesn’t start until the first one finishes.</p><h3 id=quirks>Quirks</h3><h4 id=routequeryparams-doesnt-work-with-await>route.queryParams doesn’t work with await</h4><p>When you read back what query parameters are in your current route, you must do so using an observable: route.queryParams; <a href=https://angular.io/guide/router#query-parameters>here</a> are the official docs for that. However, doing an await on the toPromise() of that Observable doesn’t work — your execution will stop at that point and it won’t continue further. It took me longer to figure this out than I would care to admit, but it turns out that queryParams is a case of an infinite Observable — subscribing to it will result in your subscription being invoked every time the query params change rather than getting the current query params at that moment only. This means that observer.complete() is never called by the internal mechanisms in it, which means an await operation on it will never complete. The trick here if you just want to get the query params once is to import either the take or first operator to get only the first result (the one at the time of execution) which looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;rxjs/add/operator/take&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>queryParams</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>route</span>.<span style=color:#a6e22e>queryParamMap</span>.<span style=color:#a6e22e>take</span>(<span style=color:#ae81ff>1</span>).<span style=color:#a6e22e>toPromise</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// access queryParams as needed
</span></span></span></code></pre></div><p>Thanks for reading, hope this article helped you! If you want to see the above code run live, check out <a href="http://embed.plnkr.co/FpBcaV/?show=preview,src%2Fapp.ts">this plnkr</a>.</p><hr><h3 id=further-reading>Further Reading</h3><p>Here are some other topics to look at for learning Observable, and recommended further reading:</p><ul><li>Cancelling observables</li><li>Unsubscribing from observables</li><li>Handling errors and catching exceptions</li><li>Writing unit tests that involve observables</li><li>Using <a href=https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44>pipe() to apply map(), reduce(), and filter()</a> on observable results</li><li>The concepts of <a href=https://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html>“Cold” and “Hot” observables</a> (e.g. observables that only begin doing things once there are subscribers versus observables that do stuff right away, with or without subscribers)</li><li><a href=https://www.learnrxjs.io/operators/filtering/distinctuntilchanged.html>distinctUntilChanged()</a> and <a href=https://www.learnrxjs.io/operators/filtering/debouncetime.html>debounceTime()</a></li></ul></div></article><div class="container mt-4"><div class=row></div></div><div class="row footer mt-5 mb-5"><div class="col-lg-12 text-end text-muted">&copy; 2026 Petro Podrezo. Powered by <a href=https://gohugo.io/ target=_blank>Hugo</a>.</div></div></div></body></html>